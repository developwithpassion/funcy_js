import { __test__, simple_memoize, memoize_on_args } from './memoize';

const { _memoize_on_args } = __test__;

describe('simple memoize', function() {
  let memoized_func = null;
  let calls_made = 0;

  beforeEach(function() {
    calls_made = 0;
    memoized_func = simple_memoize(arg => {
      calls_made++;
      return arg + 1;
    });
  });

  it('returns cached result if last arg matches arg', function() {
    let result = memoized_func(1);
    result = memoized_func(1);
    result = memoized_func(1);
    expect(calls_made).toEqual(1);
    expect(2).toEqual(result);
  });

  it('calls original function if args differ on each call', function() {
    let result = memoized_func(1);
    result = memoized_func(2);
    result = memoized_func(1);
    result = memoized_func(2);
    expect(calls_made).toEqual(4);
  });
});

describe('memoize_on_args', () => {
  describe('when creating the memoized function', () => {
    let key_mapper;
    let create_cache;
    let the_cache;
    let func_to_memoize;
    let memoized;
    let builder;

    beforeEach(() => {
      the_cache = {};
      create_cache = jest.fn();
      key_mapper = jest.fn();
      func_to_memoize = jest.fn();
      func_to_memoize.mockImplementation((a, b) => a + b);
      builder = _memoize_on_args(key_mapper, create_cache);

      create_cache.mockReturnValue(the_cache);
    });

    beforeEach(() => {
      memoized = builder(func_to_memoize);
    });

    it('creates the cache', () => {
      expect(create_cache).toHaveBeenCalledTimes(1);
    });

    describe('the memoized function', () => {
      let result;

      describe('when invoked', () => {
        describe('with arguments that have not been cached', () => {
          beforeEach(() => {
            key_mapper.mockReturnValue('a');
          });

          beforeEach(() => {
            result = memoized(1, 2);
          });

          it('puts the return value of the original function in the cache using the key generated by the key mapper', () => {
            the_cache['a'] === 3;
          });

          it('returns the result', () => {
            expect(result).toEqual(3);
          });
        });

        describe('with arguments that are in the cache', () => {
          beforeEach(() => {
            key_mapper.mockReturnValue('a');
            the_cache['a'] = 3;
          });

          beforeEach(() => {
            result = memoized(1, 2);
          });

          it('returns the value from cache', () => {
            expect(result).toEqual(3);
          });

          it('does not invoke the original function', () => {
            expect(func_to_memoize).not.toHaveBeenCalled();
          });
        });
      });
    });
  });

  describe('basic implementation - JSON stringify for key mapper', function() {
    let memoized_func = null;
    let calls_made = 0;

    beforeEach(function() {
      calls_made = 0;
      memoized_func = memoize_on_args((arg1, arg2) => {
        calls_made++;
        return arg1 + arg2;
      });
    });

    it('returns cached result if memoized func has already been called with arguments', function() {
      let result = memoized_func(1, 2);
      expect(calls_made).toEqual(1);
      expect(3).toEqual(result);
    });

    it('only calls original function when new arguments are provided', function() {
      let result = memoized_func(1, 2);
      result = memoized_func(3, 4);
      result = memoized_func(1, 2);
      result = memoized_func(3, 4);
      expect(calls_made).toEqual(2);

      expect(memoized_func(1, 2)).toEqual(3);
      expect(memoized_func(3, 4)).toEqual(7);
    });
  });
});
